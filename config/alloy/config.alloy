// config-alloy/config.alloy

// 1. Alloy Internal Server Configuration
logging {
    level  = "info"
    format = "logfmt"
}

// 2. Docker Container Discovery
discovery.docker "containers" {
    host = "unix:///var/run/docker.sock"
}

// 3. Relabeling to clean container names
//    Equivalent to your previous regex '/(.*)'
discovery.relabel "docker_logs" {
    targets = discovery.docker.containers.targets

    rule {
        source_labels = ["__meta_docker_container_name"]
        regex         = "/(.*)"
        target_label  = "container"
    }
}

// 4. Log Ingestion (Input)
loki.source.docker "default" {
    host       = "unix:///var/run/docker.sock"
    targets    = discovery.relabel.docker_logs.output
    forward_to = [loki.process.pipelines.receiver]
}

// 5. Log Processing (Pipelines)
loki.process "pipelines" {
    
    // 5.1 Drop noise: Remove self-monitoring logs
    stage.drop {
        expression = ".*(alloy|loki|grafana|alloy).*"
    }

    // ============================================
    // TRAEFIK PIPELINE
    // ============================================
    stage.match {
        selector = "{container=\"traefik\"}"
        
        stage.json {
            expressions = {
                client_ip  = "ClientHost",
                status     = "DownstreamStatus",
                method     = "RequestMethod",
                host       = "RequestHost",
                router     = "RouterName",
                duration   = "Duration",
                user_agent = "RequestHeader_User_Agent",
            }
        }
        
        stage.labels {
            values = {
                status = "status",
                method = "method",
                host   = "host",
                router = "router",
            }
        }
    }

    // ============================================
    // APACHE / PHP PIPELINE
    // ============================================
    stage.match {
        selector = "{container=~ \".*php.*|.*apache.*\"}"
        
        stage.json {
            expressions = {
                apache_time = "time",
                remote_ip   = "remote_ip",
                host        = "host",
                method      = "method",
                uri         = "uri",
                status      = "status",
                duration    = "duration_us",
                referer     = "referer",
                user_agent  = "user_agent",
            }
        }

        stage.labels {
            values = {
                status = "status",
                method = "method",
                host   = "host",
            }
        }

        // Timestamp Adjustment: "2025-12-04T15:01:17+0100"
        stage.timestamp {
            source = "apache_time"
            format = "2006-01-02T15:04:05-0700"
        }
    }

    // ============================================
    // ANUBIS PIPELINE
    // ============================================
    stage.match {
        selector = "{container=~ \".*anubis.*\"}"

        stage.json {
            expressions = {
                anubis_time  = "time",
                level        = "level",
                msg          = "msg",
                host         = "host",
                method       = "method",
                path         = "path",
                // JMESPath escape for keys with hyphens
                real_ip      = "\"x-real-ip\"",
                challenge_id = "challenge",
            }
        }

        stage.labels {
            values = {
                level  = "level",
                host   = "host",
                method = "method",
                msg    = "msg",
            }
        }

        // Anubis uses RFC3339Nano
        stage.timestamp {
            source = "anubis_time"
            format = "RFC3339Nano"
        }
    }

    // Send to final output
    forward_to = [loki.write.local.receiver]
}

// ============================================
// APACHE HOST LOGS (Legacy Applications)
// Files from /var/log/apache2 on the host
// ============================================

// 6. Discover Apache log files from host
local.file_match "apache_host_logs" {
    path_targets = [
        {"__path__" = "/var/log/apache2/*access*.log", "log_type" = "access"},
        {"__path__" = "/var/log/apache2/*error*.log", "log_type" = "error"},
        {"__path__" = "/var/log/apache2/other_vhosts_access.log", "log_type" = "access"},
    ]
}

// 7. Read Apache log files
loki.source.file "apache_host" {
    targets    = local.file_match.apache_host_logs.targets
    forward_to = [loki.process.apache_host.receiver]
}

// 8. Process Apache host logs
loki.process "apache_host" {
    
    // Add static labels for identification
    stage.static_labels {
        values = {
            job       = "apache-host",
            source    = "file",
            container = "apache-host",
        }
    }

    // Extract vhost from filename (e.g., example.com-access.log)
    stage.regex {
        expression = ".*/(?P<vhost>[^/]+?)[-_]?(access|error)\\.log$"
        source     = "filename"
    }
    stage.labels {
        values = {
            vhost = "",
        }
    }

    // ============================================
    // ACCESS LOG PIPELINE (Combined Format)
    // Format: %h %l %u %t "%r" %>s %b "%{Referer}i" "%{User-agent}i"
    // Example: 192.168.1.1 - - [14/Dec/2024:16:30:00 +0100] "GET /index.html HTTP/1.1" 200 1234 "-" "Mozilla/5.0..."
    // ============================================
    stage.match {
        selector = "{log_type=\"access\"}"
        
        stage.regex {
            expression = "^(?P<client_ip>[\\d.]+) (?P<identd>\\S+) (?P<user>\\S+) \\[(?P<timestamp>[^\\]]+)\\] \"(?P<method>\\w+) (?P<path>[^ ]*) [^\"]*\" (?P<status>\\d+) (?P<bytes>\\d+|-) \"(?P<referer>[^\"]*)\" \"(?P<user_agent>[^\"]*)\""
        }
        
        stage.labels {
            values = {
                client_ip = "",
                method    = "",
                status    = "",
            }
        }
        
        // Parse Apache timestamp format: 14/Dec/2024:16:30:00 +0100
        stage.timestamp {
            source = "timestamp"
            format = "02/Jan/2006:15:04:05 -0700"
        }
    }

    // ============================================
    // ERROR LOG PIPELINE
    // Format: [Day Mon DD HH:MM:SS.microseconds YYYY] [module:level] [pid PID] [client IP:PORT] message
    // Example: [Sat Dec 14 16:30:00.123456 2024] [php:error] [pid 12345] [client 192.168.1.1:54321] Error message
    // ============================================
    stage.match {
        selector = "{log_type=\"error\"}"
        
        stage.regex {
            expression = "^\\[(?P<timestamp>[^\\]]+)\\] \\[(?P<module>[^:]*):(?P<level>[^\\]]+)\\]( \\[pid (?P<pid>\\d+)\\])?( \\[client (?P<client_ip>[^:]+):\\d+\\])? (?P<message>.*)"
        }
        
        stage.labels {
            values = {
                level     = "",
                module    = "",
                client_ip = "",
            }
        }
        
        // Parse Apache error timestamp: Sat Dec 14 16:30:00.123456 2024
        stage.timestamp {
            source = "timestamp"
            format = "Mon Jan 02 15:04:05.000000 2006"
        }
    }

    forward_to = [loki.write.local.receiver]
}

// 9. Send to Loki (Output)
loki.write "local" {
    endpoint {
        url = "http://loki:3100/loki/api/v1/push"
    }
}